# 基于 Merkle Tree 的思想，构建项目文件说明构建

## 面临的问题

我之前在用 AI 写代码的时候，有时候会发现 AI 会写一些和项目代码不一致的代码。 详细内容见上一篇文章。

尤其是当项目结构变得比较复杂的时候，其实就是需要给 AI 提供一张地图，让他知道如何探索代码的路径。当项目变得很复杂时，AI 对代码的探索深度有时候不够，导致他写的东西和我们现有的项目代码和要求规范存在一些偏差。

目前关于项目的所有相关说明（项目使用的技术栈，项目背景，项目功能，项目的开发规范等等）都放到一个文档里面。

例如：
Claude-Code，大家会一股脑的放到 Claud.md
Codex-Cli，会放到 AGENT.md
Gemini-Cli，会放到 GEMINI.md

以致于这个指令文档无比冗余，而且膨胀。导致指令效果太差。

## 解决的思想

给 AI 提供一份实时更新的项目代码地图指引和每个模块的具体说明。

## 解决的具体策略

将文档进行分层隔离。对于 AI 的每一次会话的时候，只让 AI 读取目标模块的文档，不用消化全量的信息。提升每一次会话的指令遵循质量。

## 达到目标

1. 文档和代码的一致性问题。
2. 变更可追溯（需要思考一下，这个是否有必要？）

## 具体方法

### 结构设计

从"扁平指令"转向"分形上下文"。

1. **根目录文档**

   根目录的 README 不应包含具体代码逻辑，它只负责两件事：

   - **路由（Routing）：** 告诉 AI “什么功能去哪里找”。
   - **宪法（Constitution）：** 定义全局通用的规范（如：命名风格、错误处理标准、技术栈版本）。

2. **子模块文档**

   子目录的 README 专注于具体实现。

   **优化建议：引入 `.cursorrules` 或 `.rules` 概念** 目前主流的 AI 编程 IDE（如 Cursor, Windsurf）支持在不同目录下放置规则文件。你可以利用这一特性，不仅仅写 README（给人看的），更可以写专门给 AI 看的规则文件。

推荐的文件结构示例

```
Project_Root/
├── .cursorrules           # 【全局宪法】定义项目技术栈、全局编码规范
├── README.md              # 【全局地图】项目架构图、模块索引
├── src/
│   ├── UserModule/
│   │   ├── .cursorrules   # 【局部家规】仅适用于用户模块的逻辑（如加密标准）
│   │   ├── README.md      # 【模块说明】该模块的核心业务流、接口定义
│   │   └── ... code ...
│   ├── OrderModule/
│       ├── .cursorrules
│       └── README.md
```

### 机制优化: 重新思考"Merkle Tree"的逻辑

需要注意的点：子节点更新向上冒泡更新父节点——是一个非常棒的比喻，但在实际操作中，如果所有更新都冒泡，会带来巨大的维护成本。

#### 接口和实现分离

区分接口的变动和实现的变动。

1. 实现变更（不冒泡）

   - 如果子模块只是优化了内部算法，或者修了一个 bug，但对外提供的功能没变。

   - 策略：更新子模块 README

2. 接口/架构变动（必须冒泡）
   - 如果子模块新增了一个核心功能，或者改变了模块间的交互方式。
   - 策略：必须更新父节点（文件夹说明），因为这改变了“地图”和“路由”。

注意：你的默克尔树应该是**“有损”**的。只有**架构级**的信息才向上哈希（冒泡），细节信息留在底层。这样可以保证根目录始终清晰、简洁，不会被细节淹没。

### 执行策略

建立一套**上下文的加载协议**

1. 显示引用。

   在与 AI 对话时，遵循一套加载顺序。不要上来就问代码，而是先让 AI 读取“地图”。

   **Prompt 模板：** "我需要修改 User 模块的登录逻辑。

   1. 请先阅读 `/README.md` 确认项目架构。
   2. 然后阅读 `/src/UserModule/README.md` 获取该模块的详细约束。
   3. 最后基于以上上下文，修改 `login.ts`。"

2. 使用“伪代码”作为中间层

   在根目录的 README 中，可以使用 Mermaid 图表或伪代码来描述模块关系。AI 对结构化数据的理解远强于纯文本。

   根目录 README 示例片段：

   ```markdown
   ## 模块路由表

   | 模块     | 路径       | 核心职责         | 依赖关系        |
   | :------- | :--------- | :--------------- | :-------------- |
   | 用户中心 | /src/user  | 登录、注册、鉴权 | 独立            |
   | 订单系统 | /src/order | 下单、支付       | 依赖 [用户中心] |
   ```

### 潜在风险和应对

**风险：循环依赖与上下文割裂** 当你把指令拆得太散，AI 可能会在跨模块调用时“出现幻觉”，因为它不知道另一个模块的内部细节。

**解决方案：接口文档化** 在子模块的 README 中，必须显式定义**“Public API”**（对外暴露的接口）。

- 当 AI 在编写 `Order` 模块时，它不需要知道 `User` 模块怎么查数据库，它只需要看 `User` 模块 README 里的 `getUserById(id)` 接口定义即可。

**我的最终建议方案：**

1. **结构化：** 采用 **Root (架构/路由) + Leaf (实现/接口)** 的双层文档结构。
2. **标准化：** 使用表格、Mermaid 流程图、XML 标签等结构化格式写 README，而不是纯自然语言。
3. **过滤化（改良默克尔树）：** 仅当**接口（Public API）或架构**发生变化时，才触发向上更新；内部实现细节只在叶子节点闭环。
4. **工具化：** 充分利用 `.cursorrules` 或 IDE 的 `@codebase` 功能，让 AI 自动索引这些文档。

---

## 一些需要解决的问题

1. 每个文件内容的边界和职能如何清晰确定。

---

指令分类

1. **Normative（规范性/必须遵守）**：用 MUST/SHOULD/MAY 这种 RFC 语气，短句、可验证。
2. **Descriptive（描述性/解释背景）**：放在“Why/Context”，避免和 MUST 混写导致模型误判优先级。

## 5) 把“最容易被忽略的细节”转成机器可检查的护栏

纯文档最终还是会被忽略，所以建议把关键约束尽量落到工具上：

- **lint/format/test 必须可一键运行**（哪怕是最小化）
- **pre-commit**：在提交前强制跑基础检查
- **契约测试/接口快照**：域之间的输入输出用测试固化
- **目录级别的“禁止越界”规则**：例如 lint rule 或简单脚本检测跨域 import

文档负责“解释与导航”，工具负责“强制执行”，两者结合效果最好。

```markdown
project-root/
AGENT.md
project-docs/
ai-workflow.md
architectur.md
decisions/
```

我觉得我在构建这个框架的时候，可能就是要去除了要去说把整个的文件结构搭出来之外，然后每一个文件它的规范是什么，然后最好还可以去给 AI 提供一些 command slash，就是一些快捷的指令可以让他快速的去做查询,然后还有一些就是在项目开始的时候做一些初始化，比如说 OpenSpec 的这种初始化的东西

---

实际上，都要做的是，定义结构设计；更新机制设计；执行策略设计；
